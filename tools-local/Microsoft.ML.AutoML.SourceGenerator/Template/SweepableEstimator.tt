<#@ template language="C#" linePragmas="false" visibility = "internal"#>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>

using System.Collections.Generic;
using Newtonsoft.Json;
using SweepableEstimator = Microsoft.ML.AutoML.SweepableEstimator;
using Microsoft.ML.AutoML.CodeGen;
using ColorsOrder = Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorsOrder;
using ColorBits = Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorBits;
using ResizingKind = Microsoft.ML.Transforms.Image.ImageResizingEstimator.ResizingKind;
using Anchor = Microsoft.ML.Transforms.Image.ImageResizingEstimator.Anchor;

namespace <#=NameSpace#>
{
    internal partial class <#=ClassName#> : SweepableEstimator
    {
        public <#=ClassName#>()
        {
            this.EstimatorType = EstimatorType.<#=ClassName#>;
        }
    
<# foreach(var arg in ArgumentsList){
    var typeAttributeName = Utils.CapitalFirstLetter(arg.ArgumentType);
    var propertyName = Utils.CapitalFirstLetter(arg.ArgumentName);#>
        [<#=typeAttributeName#>]
        [JsonProperty(NullValueHandling=NullValueHandling.Ignore)]
        public string <#=propertyName#> { get; set; }

<#}#>
        public override IEnumerable<string> CSharpUsingStatements 
        {
            get => new string[] {<#=Utils.PrettyPrintListOfString(UsingStatements.Select(x => $"using {x};"))#>};
        }

        public override IEnumerable<string> NugetDependencies
        {
            get => new string[] {<#=Utils.PrettyPrintListOfString(NugetDependencies)#>};
        }

        public override string FunctionName 
        {
            get => "<#=Utils.GetPrefix(Type)#>.<#=FunctionName#>";
        }

        public override string ToCSharpCode()
        {
<#if (Type == "BinaryClassification" || Type == "MultiClassification" || Type == "Regression" || Type == "Ranking"){#>
            return this.BuildCSharpCodeForTrainers();
<#}else if (Type == "OneVersusAll"){#>
            return this.BuildCSharpCodeForOva();
<#}else{#>
            return this.BuildCSharpCodeForTransformers();
<#}#>
        }

        internal override void UpdatePropertiesFromOptions(Dictionary<string, string> options)
        {
<# foreach(var arg in ArgumentsList){
    var typeAttributeName = arg.ArgumentType;
    var propertyName = Utils.CapitalFirstLetter(arg.ArgumentName);
    if(typeAttributeName == "integer"){#>
            this.<#=propertyName#> = options.ContainsKey(nameof(this.<#=propertyName#>))? this.ToIntegerString(options[nameof(this.<#=propertyName#>)]) : this.<#=propertyName#>;
    <#}else{#>
            this.<#=propertyName#> = options.ContainsKey(nameof(this.<#=propertyName#>))? options[nameof(this.<#=propertyName#>)] : this.<#=propertyName#>;
    <#}}#>
        }
    }
}

<#+
public string NameSpace {get;set;}
public string ClassName {get;set;}
public string FunctionName {get;set;}
public string Type {get;set;}
public IEnumerable<Argument> ArgumentsList {get;set;}
public IEnumerable<string> UsingStatements {get; set;}
public IEnumerable<string> NugetDependencies {get; set;}
#>