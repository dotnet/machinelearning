using System;
using System.Collections.Generic;
using System.Numerics;
using System.Text;

namespace Microsoft.ML.TimeSeries
{
    /// <summary>
    /// this class is used to detect the periodicity automatically
    /// </summary>
    internal class SerialCorrelation
    {
        /// <summary>
        /// the ratio of all potential lags. this value should not be greater than 0.2, otherwise, over-fit.
        /// </summary>
        private const double LagRatio = 0.25;

        /// <summary>
        /// in practice, the max lag very rarely exceed 365, which lacks of strong interpretation, and which also brings performance overhead.
        /// </summary>
        private const int MaxLag = 400;

        /// <summary>
        /// suppose the length of time series is 651, now we found an period is 128, then 651/128 = 5, which means there are at most 5 recurrent period. this is too small, the significance build upon this is not trustable.
        /// </summary>
        private const int MinRecurrentCount = 8;

        /// <summary>
        /// when input time series is with very close values (i.e., different is smaller than E-20), the accuracy of double could distort the
        /// final trend signal. any seasonal signal under such circumstance becomes unreliable.
        /// so use this threshold to eliminate such kind of time series. here set to 1e-10 is for conservative consideration.
        /// </summary>
        private const double MinEnergyThreshold = 1e-10;

        /// <summary>
        /// this is a slow version of calculating Acf, with complexity is O(n^2).
        /// the assumptions needed for applying serial correlation is, the series should be generated by a second-order stationary process.
        /// therefore, one should conduct de-trend process before running serial correlation.
        /// </summary>
        internal static List<double> Acf(ICollection<double> y)
        {
            //ExtendedDiagnostics.EnsureArgumentNotNull(y, nameof(y));

            if (y.Count <= BasicParameters.MinTimeSeriesLength)
                throw new Exception("input data structure cannot be 0-length: serial correlation");

            List<double> values = new List<double>(y);
            double mean = 0;
            foreach (double value in values)
                mean += value;
            mean /= values.Count;
            double var = 0;
            for (int i = 0; i < values.Count; i++)
            {
                values[i] -= mean;
                var += values[i] * values[i];
            }

            List<double> energies = new List<double>();
            int maxLag = Math.Min((int)(y.Count * SerialCorrelation.LagRatio), SerialCorrelation.MaxLag);
            for (int lag = 0; lag <= maxLag; lag++)
            {
                double corr = 0;
                for (int i = 0; i + lag < values.Count; i++)
                {
                    corr += values[i] * values[i + lag];
                }
                energies.Add(corr / var);
            }
            return energies;
        }

        /// <summary>
        /// Obtain the period by adopting techniques of spectral analysis. which is founded by
        /// the fourier analysis. returns -1 means there's no significant period. otherwise, a period
        /// is returned.
        /// </summary>
        /// <param name="y">the input time series</param>
        /// <param name="confidence">confidence</param>
        public static int Period(IReadOnlyList<double> y, out double confidence)
        {
            //ExtendedDiagnostics.EnsureArgumentNotNull(y, nameof(y));

            if (y.Count < BasicParameters.MinTimeSeriesLength)
                throw new Exception("input data structure cannot be 0-length: serial correlation");

            confidence = 0;

            List<double> values = new List<double>(y);

            double mean = 0;
            foreach (double value in values)
                mean += value;
            mean /= values.Count;
            for (int i = 0; i < values.Count; i++)
            {
                values[i] -= mean;
            }

            // caution1: need to extend to power of 2 explicitly, by adding 0. it is clear that adding any number of 0 will not affect the Acf results.
            int newLength = Get2Power(y.Count);
            for (int i = y.Count; i < newLength; i++)
            {
                values.Add(0);
            }

            // caution2: need to double the length. this is used to make the "Summation lemma" works. you can check it out by proving the WK theorem.
            Complex[] x = new Complex[values.Count * 2];
            for (int i = 0; i < values.Count; i++)
            {
                x[i] = new Complex(values[i], 0);
                x[i + values.Count] = Complex.Zero;
            }

            Complex[] z = FftTransform.Fft(x);

            // Y is the key data source for analyzing period patterns.
            /* here w is the periodogram, which indicates the square of "energy" on the  frequency domain. specifically,
             * w[j] = a[j]^2+b[j]^2, where a and b are Fourier Coefficients for cosine and sine, specifically,
             * x(t) = a0+sum(a[j]cos(2Pi * f[j]t)+b[j]sin(2Pi * f[j]t)
             */
            Complex[] w = new Complex[x.Length];
            for (int i = 0; i < x.Length; i++)
            {
                w[i] = z[i] * Complex.Conjugate(z[i]);
            }

            int bestFreq;
            int secondFreq;

            FindBestTwoFrequencies(w, y.Count, out bestFreq, out secondFreq);

            // when the time series is very short, and there exist no seasonal, the loop above may not access
            if (bestFreq == -1)
                return -1;

            // next check if the period is statistical significant
            /* r is an auto-correlation function of input y, but without normalization. specifically,
             * r[j] = sum(x[i]x[i+j]).
             */
            Complex[] r = FftTransform.RevertFft(w);

            /* pick the best frequency by inspecting the auto-correlation energy (pick the highest) in time-domain.
                         * in the normal case, usually, when the time series is with period T, then the best frequency is N/T, while the second frequency would be N/2T,
                         * because period = T implies period = nT, where n is an integer.
                         * in such a case, smaller period will win out on the autu-correlation energy list, due to the property of auto-correlation.
                         */
            int firstPeriod = -1;
            int secondPeriod = -1;
            double firstTimeDomainEnergy = -1;
            double secondTimeDomainEnergy = -1;
            firstPeriod = FindBestPeriod(r, bestFreq, y.Count, out firstTimeDomainEnergy);
            if (secondFreq != -1)
            {
                secondPeriod = FindBestPeriod(r, secondFreq, y.Count, out secondTimeDomainEnergy);
            }
            if (firstPeriod == -1 && secondPeriod == -1)
                return -1;
            int truePeriod;
            double trueTimeDomainEnergy;
            if (firstPeriod == -1)
            {
                truePeriod = secondPeriod;
                trueTimeDomainEnergy = secondTimeDomainEnergy;
            }
            else if (secondPeriod == -1)
            {
                truePeriod = firstPeriod;
                trueTimeDomainEnergy = firstTimeDomainEnergy;
            }
            else
            {
                if (firstPeriod == secondPeriod)
                {
                    truePeriod = firstPeriod;
                    trueTimeDomainEnergy = firstTimeDomainEnergy;
                }
                else
                {
                    // hueristic: if the second frequency is with somewhat higher energy in time domain, we think it is a better candidate
                    if (secondTimeDomainEnergy > firstTimeDomainEnergy * 1.05)
                    {
                        truePeriod = secondPeriod;
                        trueTimeDomainEnergy = secondTimeDomainEnergy;
                    }
                    else
                    {
                        truePeriod = firstPeriod;
                        trueTimeDomainEnergy = firstTimeDomainEnergy;
                    }
                }
            }
            trueTimeDomainEnergy /= r[0].Real;

            // this is a key equation, which is named the "testing for randomness with the correlogram". /ref: http://www.ltrr.arizona.edu/~dmeko/notes_3.pdf
            // actually, 1.96 is for the 2-sigma, which has 95% statistical confidence. 2.58 is for 99% confidence, 2.85 for 99.5% confidence
            /* increasing the threshold aims to mitigate the fake seasonal component caused by outliers. in practice, if there exist true seasonal component,
             * such as BirdStrike/Appdownloads, the energy is far larger than threshold, hence change threshold from 2.85 to 4.0 have no impact (tested);
             */
            double threshold = 4.0 / Math.Sqrt(y.Count);

            if (trueTimeDomainEnergy < threshold || r[truePeriod].Real < MinEnergyThreshold)
                return -1;

            confidence = MathUtility.GaussianSignificance(trueTimeDomainEnergy, 0, 1.0 / Math.Sqrt(y.Count));
            return truePeriod;
        }

        /// <summary>
        /// in order to pick up a proper frequency robustly (this is useful especially for large frequency, or small period, e.g., period = 2),
        /// this method aims to pick up the top two frequencies for further evaluation.
        /// of course, the energy of the second frequency (in frequency domain) must be at similar magnitude compared with the energy of the first
        /// frequency.
        /// </summary>
        /// <param name="w">the energy list in the frequency domain, the index is the frequency.</param>
        /// <param name="timeSeriesLength">the original time series length</param>
        /// <param name="bestFreq">the frequency with highest energy</param>
        /// <param name="secondFreq">the frequency with second highest energy</param>
        private static void FindBestTwoFrequencies(Complex[] w, int timeSeriesLength, out int bestFreq, out int secondFreq)
        {
            bestFreq = -1;
            double bestEnergy = -1.0;
            secondFreq = -1;
            double secondEnergy = -1.0;

            if (w.Length < 2)
                return;

            List<double> energies = new List<double>();

            /* length of time series divided by frequency is period. it is obvious that the period should be larger than 1 and smaller than the total length, and is an integer */
            for (int i = w.Length / timeSeriesLength; i < w.Length / 2 + 1; i++)
            {
                double nextWeight = w[i].Magnitude;
                energies.Add(nextWeight);

                if (nextWeight > bestEnergy)
                {
                    bestEnergy = nextWeight;
                    bestFreq = i;
                }
            }

            // once we found a best frequency, the region formed by lower bound to upper bound corresponding to this frequency will not be inspected anymore. because they all share the same period.
            int period = w.Length / bestFreq;
            double lowerBound = w.Length * 1.0 / (period + 1);
            double upperBound = w.Length * 1.0 / (period - 1);

            for (int i = w.Length / timeSeriesLength; i < w.Length / 2 + 1; i++)
            {
                if (i > lowerBound && i < upperBound)
                    continue;
                double weight = w[i].Magnitude;
                if (weight > secondEnergy)
                {
                    double prevWeight = 0;
                    if (i > 0)
                        prevWeight = w[i - 1].Magnitude;
                    double nextWeight = 0;
                    if (i < w.Length - 1)
                        nextWeight = w[i + 1].Magnitude;

                    // should be a local maximum
                    if (weight >= prevWeight && weight >= nextWeight)
                    {
                        secondEnergy = nextWeight;
                        secondFreq = i;
                    }
                }
            }
            double typycalEnergy = MathUtility.QuickMedian(energies);

            // the second energy must be at least significantly large enough than typical energies, and also similar to best energy at magnitude level.
            if (typycalEnergy * 6.0 < secondEnergy && secondEnergy * 10.0 > bestEnergy)
                return;

            // set the second frequency to -1, since it is obviously not strong enought to compete with the best energy.
            secondFreq = -1;
        }

        /// <summary>
        /// given a frequency F represented by an integer, we aim to find the best period by inspecting the auto-correlation function in time domain.
        /// since either frequency or the period is an integer, so the possible period located within
        /// [N/(F+1), N/(F-1)], we need to check this domain, and pick the best one. where N is the length of the augmented time series
        /// </summary>
        /// <param name="r">the auto-correlation function of the augmented time series</param>
        /// <param name="frequency">the input frequency candidate</param>
        /// <param name="timeSeriesLength">the length of the original time series, this is used for post processing to reduce false positive</param>
        /// <param name="energy">output the energy on the auto-correlation function</param>
        /// <returns>return the best period estimated</returns>
        private static int FindBestPeriod(Complex[] r, int frequency, int timeSeriesLength, out double energy)
        {
            energy = -1;

            // this will never make sense of a seasonal signal
            if (frequency <= 1)
                return -1;

            int lowerBound = r.Length / (frequency + 1);
            int upperBound = r.Length / (frequency - 1);
            int bestPeriod = -1;
            for (int i = lowerBound; i <= upperBound && i < r.Length; i++)
            {
                var currentEnergy = r[i].Real;
                if (currentEnergy > energy)
                {
                    energy = currentEnergy;
                    bestPeriod = i;
                }
            }

            /* condition1: period does not make sense, since the corresponding zone in the auto-correlation energy list are all negative.
             * condition2: for real dataset, we do not think there will exist such long period. this is used to reduce false-positive
             * condition3: the number of repeats under this period is too few. this is used to reduce false-positive
             */
            if (bestPeriod <= 1 || bestPeriod > SerialCorrelation.MaxLag || timeSeriesLength < SerialCorrelation.MinRecurrentCount * bestPeriod)
            {
                energy = -1;
                return -1;
            }
            return bestPeriod;
        }

        /// <summary>
        /// this is a fast version of calculating Acf, by using FftTransform. the complexity is O(n log n). Basically
        /// 1) Z = FftTransform (X)
        /// 2) Y = ZZ*
        /// 3) R = IFFT(Y)
        /// the series R is just the Acf.
        /// </summary>
        public static List<double> FastAcf(ICollection<double> y)
        {
            //ExtendedDiagnostics.EnsureArgumentNotNull(y, nameof(y));

            if (y.Count <= BasicParameters.MinTimeSeriesLength)
                throw new Exception("input data structure cannot be 0-length: serial correlation");

            List<double> values = new List<double>(y);

            double mean = 0;
            foreach (double value in values)
                mean += value;
            mean /= values.Count;
            for (int i = 0; i < values.Count; i++)
            {
                values[i] -= mean;
            }

            // caution1: need to extend to power of 2 explicitly, by adding 0. it is clear that adding any number of 0 will not affect the Acf results.
            int newLength = Get2Power(y.Count);
            for (int i = y.Count; i < newLength; i++)
            {
                values.Add(0);
            }

            // caution2: need to double the length. this is used to make the "Summation lemma" works. you can check it out by proving the WK theorem.
            Complex[] x = new Complex[values.Count * 2];
            for (int i = 0; i < values.Count; i++)
            {
                x[i] = new Complex(values[i], 0);
                x[i + values.Count] = Complex.Zero;
            }
            Complex[] z = FftTransform.Fft(x);
            Complex[] w = new Complex[x.Length];
            for (int i = 0; i < x.Length; i++)
            {
                w[i] = z[i] * Complex.Conjugate(z[i]);
            }

            Complex[] r = FftTransform.RevertFft(w);
            double var = r[0].Real;
            List<double> energies = new List<double>();
            int maxLag = Math.Min((int)(y.Count * SerialCorrelation.LagRatio), SerialCorrelation.MaxLag);
            for (int lag = 0; lag <= maxLag; lag++)
            {
                energies.Add(r[lag].Real / var);
            }
            return energies;
        }

        /// <summary>
        /// get the smallest 2^k which is equal or greater than n
        /// </summary>
        private static int Get2Power(int n)
        {
            int result = 1;
            bool meet1 = false; // check is n is just equals to 2^k for some k
            while (n > 1)
            {
                if ((n & 1) != 0)
                    meet1 = true;
                result = result << 1;
                n = n >> 1;
            }
            if (meet1)
                result = result << 1;
            return result;
        }
    }
}
