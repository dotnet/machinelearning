<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System;
using Microsoft.ML;
using Microsoft.ML.StaticPipe;
using Microsoft.ML.Transforms.Conversions;

namespace Microsoft.ML.StaticPipe
{
    public static partial class TermStaticExtensions
    {
        // Do not edit this file directly. Rather, it is generated out of TermStaticExtensions.tt.
<#
// Let's skip the time-based types for now.
foreach (string typeName in new string[] { "string", "float", "double", "sbyte", "short", "int", "long", "byte", "ushort", "uint", "ulong", "bool" }) {
bool startRegionBlock = true;
#>

        #region For <#=typeName#> inputs.
<#
foreach (bool inputIsKey in new bool[] { false, true }) {
foreach (string arityName in new string[] { "Scalar", "Vector", "VarVector" }) {
string onFitType = typeName == "string" ? "ReadOnlyMemory<char>" : typeName;
bool omitInputArity = arityName == "Scalar" && inputIsKey;
bool isNumeric = typeName != "string" && typeName != "bool";
bool isScalar = arityName == "Scalar";

if (!startRegionBlock) { // Put lines between the declarations to make them look pretty, but not after the region tag.
#>

<#}
startRegionBlock = false;
#>
        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
<#
if (typeName == "string") { #>
        /// Because the empty string is never entered into the dictionary, it will always map to the missing key.
<# }
if (typeName == "float" || typeName == "double") { #>
        /// Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
<# }
if (!isScalar && isNumeric && !inputIsKey) { #>
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
<# }
if (inputIsKey) { #>
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
<# }

#>
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static <#=isScalar?"":arityName+"<"#>Key<uint, <#=typeName#>><#=isScalar?"":">"#> ToKey<#=inputIsKey?"<T>":""#>(this <#=omitInputArity?"":arityName+"<"#><#=inputIsKey?"Key<T, ":""#><#=typeName#>><#=inputIsKey&&!isScalar?">":""#> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<<#=onFitType#>>.OnFit onFit = null)
            => new Impl<#=arityName#><<#=typeName#>>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));
<#
} }
#>
        #endregion
<#
}
#>
    }
}