// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System;
using Microsoft.ML.Transforms;

namespace Microsoft.ML.StaticPipe
{
    public static partial class TermStaticExtensions
    {
        // Do not edit this file directly. Rather, it is generated out of TermStaticExtensions.tt.
        /// <summary>
        /// Information on the result of fitting a to-key transform.
        /// </summary>
        /// <typeparam name="T">The type of the values.</typeparam>
        public sealed class ToKeyFitResult<T>
        {
            /// <summary>
            /// For user defined delegates that accept instances of the containing type.
            /// </summary>
            /// <param name="result"></param>
            public delegate void OnFit(ToKeyFitResult<T> result);

            // At the moment this is empty. Once PR #863 clears, we can change this class to hold the output
            // key-values metadata.

            [BestFriend]
            internal ToKeyFitResult(ValueToKeyMappingTransformer.TermMap map)
            {
            }
        }

        #region For string inputs.
        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because the empty string is never entered into the dictionary, it will always map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Key<uint, string> ToKey(this Scalar<string> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<ReadOnlyMemory<char>>.OnFit onFit = null)
            => new ImplScalar<string>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because the empty string is never entered into the dictionary, it will always map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Vector<Key<uint, string>> ToKey(this Vector<string> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<ReadOnlyMemory<char>>.OnFit onFit = null)
            => new ImplVector<string>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because the empty string is never entered into the dictionary, it will always map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static VarVector<Key<uint, string>> ToKey(this VarVector<string> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<ReadOnlyMemory<char>>.OnFit onFit = null)
            => new ImplVarVector<string>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because the empty string is never entered into the dictionary, it will always map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Key<uint, string> ToKey<T>(this Key<T, string> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<ReadOnlyMemory<char>>.OnFit onFit = null)
            => new ImplScalar<string>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because the empty string is never entered into the dictionary, it will always map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Vector<Key<uint, string>> ToKey<T>(this Vector<Key<T, string>> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<ReadOnlyMemory<char>>.OnFit onFit = null)
            => new ImplVector<string>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because the empty string is never entered into the dictionary, it will always map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static VarVector<Key<uint, string>> ToKey<T>(this VarVector<Key<T, string>> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<ReadOnlyMemory<char>>.OnFit onFit = null)
            => new ImplVarVector<string>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));
        #endregion

        #region For float inputs.
        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Key<uint, float> ToKey(this Scalar<float> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<float>.OnFit onFit = null)
            => new ImplScalar<float>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Vector<Key<uint, float>> ToKey(this Vector<float> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<float>.OnFit onFit = null)
            => new ImplVector<float>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static VarVector<Key<uint, float>> ToKey(this VarVector<float> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<float>.OnFit onFit = null)
            => new ImplVarVector<float>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Key<uint, float> ToKey<T>(this Key<T, float> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<float>.OnFit onFit = null)
            => new ImplScalar<float>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Vector<Key<uint, float>> ToKey<T>(this Vector<Key<T, float>> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<float>.OnFit onFit = null)
            => new ImplVector<float>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static VarVector<Key<uint, float>> ToKey<T>(this VarVector<Key<T, float>> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<float>.OnFit onFit = null)
            => new ImplVarVector<float>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));
        #endregion

        #region For double inputs.
        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Key<uint, double> ToKey(this Scalar<double> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<double>.OnFit onFit = null)
            => new ImplScalar<double>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Vector<Key<uint, double>> ToKey(this Vector<double> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<double>.OnFit onFit = null)
            => new ImplVector<double>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static VarVector<Key<uint, double>> ToKey(this VarVector<double> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<double>.OnFit onFit = null)
            => new ImplVarVector<double>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Key<uint, double> ToKey<T>(this Key<T, double> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<double>.OnFit onFit = null)
            => new ImplScalar<double>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Vector<Key<uint, double>> ToKey<T>(this Vector<Key<T, double>> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<double>.OnFit onFit = null)
            => new ImplVector<double>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static VarVector<Key<uint, double>> ToKey<T>(this VarVector<Key<T, double>> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<double>.OnFit onFit = null)
            => new ImplVarVector<double>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));
        #endregion

        #region For sbyte inputs.
        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Key<uint, sbyte> ToKey(this Scalar<sbyte> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<sbyte>.OnFit onFit = null)
            => new ImplScalar<sbyte>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Vector<Key<uint, sbyte>> ToKey(this Vector<sbyte> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<sbyte>.OnFit onFit = null)
            => new ImplVector<sbyte>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static VarVector<Key<uint, sbyte>> ToKey(this VarVector<sbyte> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<sbyte>.OnFit onFit = null)
            => new ImplVarVector<sbyte>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Key<uint, sbyte> ToKey<T>(this Key<T, sbyte> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<sbyte>.OnFit onFit = null)
            => new ImplScalar<sbyte>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Vector<Key<uint, sbyte>> ToKey<T>(this Vector<Key<T, sbyte>> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<sbyte>.OnFit onFit = null)
            => new ImplVector<sbyte>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static VarVector<Key<uint, sbyte>> ToKey<T>(this VarVector<Key<T, sbyte>> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<sbyte>.OnFit onFit = null)
            => new ImplVarVector<sbyte>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));
        #endregion

        #region For short inputs.
        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Key<uint, short> ToKey(this Scalar<short> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<short>.OnFit onFit = null)
            => new ImplScalar<short>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Vector<Key<uint, short>> ToKey(this Vector<short> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<short>.OnFit onFit = null)
            => new ImplVector<short>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static VarVector<Key<uint, short>> ToKey(this VarVector<short> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<short>.OnFit onFit = null)
            => new ImplVarVector<short>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Key<uint, short> ToKey<T>(this Key<T, short> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<short>.OnFit onFit = null)
            => new ImplScalar<short>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Vector<Key<uint, short>> ToKey<T>(this Vector<Key<T, short>> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<short>.OnFit onFit = null)
            => new ImplVector<short>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static VarVector<Key<uint, short>> ToKey<T>(this VarVector<Key<T, short>> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<short>.OnFit onFit = null)
            => new ImplVarVector<short>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));
        #endregion

        #region For int inputs.
        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Key<uint, int> ToKey(this Scalar<int> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<int>.OnFit onFit = null)
            => new ImplScalar<int>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Vector<Key<uint, int>> ToKey(this Vector<int> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<int>.OnFit onFit = null)
            => new ImplVector<int>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static VarVector<Key<uint, int>> ToKey(this VarVector<int> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<int>.OnFit onFit = null)
            => new ImplVarVector<int>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Key<uint, int> ToKey<T>(this Key<T, int> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<int>.OnFit onFit = null)
            => new ImplScalar<int>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Vector<Key<uint, int>> ToKey<T>(this Vector<Key<T, int>> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<int>.OnFit onFit = null)
            => new ImplVector<int>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static VarVector<Key<uint, int>> ToKey<T>(this VarVector<Key<T, int>> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<int>.OnFit onFit = null)
            => new ImplVarVector<int>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));
        #endregion

        #region For long inputs.
        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Key<uint, long> ToKey(this Scalar<long> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<long>.OnFit onFit = null)
            => new ImplScalar<long>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Vector<Key<uint, long>> ToKey(this Vector<long> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<long>.OnFit onFit = null)
            => new ImplVector<long>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static VarVector<Key<uint, long>> ToKey(this VarVector<long> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<long>.OnFit onFit = null)
            => new ImplVarVector<long>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Key<uint, long> ToKey<T>(this Key<T, long> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<long>.OnFit onFit = null)
            => new ImplScalar<long>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Vector<Key<uint, long>> ToKey<T>(this Vector<Key<T, long>> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<long>.OnFit onFit = null)
            => new ImplVector<long>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static VarVector<Key<uint, long>> ToKey<T>(this VarVector<Key<T, long>> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<long>.OnFit onFit = null)
            => new ImplVarVector<long>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));
        #endregion

        #region For byte inputs.
        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Key<uint, byte> ToKey(this Scalar<byte> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<byte>.OnFit onFit = null)
            => new ImplScalar<byte>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Vector<Key<uint, byte>> ToKey(this Vector<byte> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<byte>.OnFit onFit = null)
            => new ImplVector<byte>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static VarVector<Key<uint, byte>> ToKey(this VarVector<byte> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<byte>.OnFit onFit = null)
            => new ImplVarVector<byte>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Key<uint, byte> ToKey<T>(this Key<T, byte> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<byte>.OnFit onFit = null)
            => new ImplScalar<byte>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Vector<Key<uint, byte>> ToKey<T>(this Vector<Key<T, byte>> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<byte>.OnFit onFit = null)
            => new ImplVector<byte>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static VarVector<Key<uint, byte>> ToKey<T>(this VarVector<Key<T, byte>> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<byte>.OnFit onFit = null)
            => new ImplVarVector<byte>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));
        #endregion

        #region For ushort inputs.
        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Key<uint, ushort> ToKey(this Scalar<ushort> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<ushort>.OnFit onFit = null)
            => new ImplScalar<ushort>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Vector<Key<uint, ushort>> ToKey(this Vector<ushort> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<ushort>.OnFit onFit = null)
            => new ImplVector<ushort>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static VarVector<Key<uint, ushort>> ToKey(this VarVector<ushort> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<ushort>.OnFit onFit = null)
            => new ImplVarVector<ushort>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Key<uint, ushort> ToKey<T>(this Key<T, ushort> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<ushort>.OnFit onFit = null)
            => new ImplScalar<ushort>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Vector<Key<uint, ushort>> ToKey<T>(this Vector<Key<T, ushort>> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<ushort>.OnFit onFit = null)
            => new ImplVector<ushort>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static VarVector<Key<uint, ushort>> ToKey<T>(this VarVector<Key<T, ushort>> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<ushort>.OnFit onFit = null)
            => new ImplVarVector<ushort>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));
        #endregion

        #region For uint inputs.
        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Key<uint, uint> ToKey(this Scalar<uint> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<uint>.OnFit onFit = null)
            => new ImplScalar<uint>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Vector<Key<uint, uint>> ToKey(this Vector<uint> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<uint>.OnFit onFit = null)
            => new ImplVector<uint>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static VarVector<Key<uint, uint>> ToKey(this VarVector<uint> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<uint>.OnFit onFit = null)
            => new ImplVarVector<uint>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Key<uint, uint> ToKey<T>(this Key<T, uint> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<uint>.OnFit onFit = null)
            => new ImplScalar<uint>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Vector<Key<uint, uint>> ToKey<T>(this Vector<Key<T, uint>> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<uint>.OnFit onFit = null)
            => new ImplVector<uint>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static VarVector<Key<uint, uint>> ToKey<T>(this VarVector<Key<T, uint>> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<uint>.OnFit onFit = null)
            => new ImplVarVector<uint>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));
        #endregion

        #region For ulong inputs.
        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Key<uint, ulong> ToKey(this Scalar<ulong> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<ulong>.OnFit onFit = null)
            => new ImplScalar<ulong>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Vector<Key<uint, ulong>> ToKey(this Vector<ulong> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<ulong>.OnFit onFit = null)
            => new ImplVector<ulong>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static VarVector<Key<uint, ulong>> ToKey(this VarVector<ulong> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<ulong>.OnFit onFit = null)
            => new ImplVarVector<ulong>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Key<uint, ulong> ToKey<T>(this Key<T, ulong> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<ulong>.OnFit onFit = null)
            => new ImplScalar<ulong>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Vector<Key<uint, ulong>> ToKey<T>(this Vector<Key<T, ulong>> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<ulong>.OnFit onFit = null)
            => new ImplVector<ulong>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static VarVector<Key<uint, ulong>> ToKey<T>(this VarVector<Key<T, ulong>> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<ulong>.OnFit onFit = null)
            => new ImplVarVector<ulong>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));
        #endregion

        #region For bool inputs.
        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Key<uint, bool> ToKey(this Scalar<bool> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<bool>.OnFit onFit = null)
            => new ImplScalar<bool>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Vector<Key<uint, bool>> ToKey(this Vector<bool> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<bool>.OnFit onFit = null)
            => new ImplVector<bool>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static VarVector<Key<uint, bool>> ToKey(this VarVector<bool> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<bool>.OnFit onFit = null)
            => new ImplVarVector<bool>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Key<uint, bool> ToKey<T>(this Key<T, bool> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<bool>.OnFit onFit = null)
            => new ImplScalar<bool>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static Vector<Key<uint, bool>> ToKey<T>(this Vector<Key<T, bool>> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<bool>.OnFit onFit = null)
            => new ImplVector<bool>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>
        /// <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
        /// <returns>The key-valued column.</returns>
        public static VarVector<Key<uint, bool>> ToKey<T>(this VarVector<Key<T, bool>> input,
                KeyValueOrder order = DefSort, int maxItems = DefMax, ToKeyFitResult<bool>.OnFit onFit = null)
            => new ImplVarVector<bool>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, Wrap(onFit)));
        #endregion
    }
}